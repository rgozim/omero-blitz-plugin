package org.openmicroscopy.blitz

import groovy.transform.CompileStatic
import org.gradle.api.Action
import org.gradle.api.GradleException
import org.gradle.api.Plugin
import org.gradle.api.Project
import org.gradle.api.artifacts.ResolvedArtifact
import org.gradle.api.file.CopySpec
import org.gradle.api.file.FileCopyDetails
import org.gradle.api.logging.Logger
import org.gradle.api.logging.Logging
import org.gradle.api.plugins.JavaPlugin
import org.gradle.api.plugins.JavaPluginConvention
import org.gradle.api.tasks.SourceSet
import org.gradle.api.tasks.Sync
import org.gradle.api.tasks.compile.JavaCompile
import org.openmicroscopy.api.ApiPlugin
import org.openmicroscopy.api.tasks.SplitTask
import org.openmicroscopy.blitz.extensions.BlitzExtension
import org.openmicroscopy.dsl.DslPlugin
import org.openmicroscopy.dsl.FileTypes
import org.openmicroscopy.dsl.extensions.VelocityExtension
import org.openmicroscopy.dsl.tasks.GeneratorBaseTask

@CompileStatic
class BlitzPlugin implements Plugin<Project> {

    static final String GROUP = BlitzPluginBase.GROUP
    static final String TASK_IMPORT_MAPPINGS = "importMappings"
    static final String TASK_IMPORT_DATABASE_TYPES = 'importDatabaseTypes'

    private static final Logger Log = Logging.getLogger(BlitzPlugin)

    @Override
    void apply(Project project) {
        if (project.plugins.withType(DslPlugin)) {
            throw new GradleException("Blitz overrides dsl plugin.")
        }
        // Apply base plugin
        project.plugins.apply(BlitzPluginBase)

        // velocity extension
        BlitzExtension blitz = BlitzPluginBase.getBlitzExtension(project.extensions)
        VelocityExtension velocity = BlitzPluginBase.getVelocityExtension(blitz)

        // Register tasks required to load default properties
        // Set default dir for files generated by .combinedFiles files
        blitz.outputDir = "src/generated"
        blitz.combined.template = "combined.vm"
        blitz.combined.outputDir = "${project.buildDir}/combined"
        blitz.omeXmlFiles = project.files(project.tasks.named(TASK_IMPORT_MAPPINGS))
        blitz.databaseTypes = project.files(project.tasks.named(TASK_IMPORT_DATABASE_TYPES))

        // Set default for velocity config
        velocity.checkEmptyObjects = false

        // Callback based configuration
        registerImportTasks(project)
        configureForJavaPlugin(project, blitz)
        configureForApiPlugin(project)
    }

    private static registerImportTasks(Project project) {
        // Configuration of import tasks takes place in an afterEvaluate block as
        // we have to wait for project evaluation to complete before we can obtain
        // a reference to an omero-model jar from dependencies.
        project.afterEvaluate {
            ResolvedArtifact omeroModel = new ImportHelper(project)
                    .getOmeroModelArtifact()
            if (!omeroModel) {
                throw new GradleException("Can\'t find omero-model as a dependency")
            }

            CopySpec copySpec = project.copySpec(new Action<CopySpec>() {
                @Override
                void execute(CopySpec copySpec) {
                    copySpec.from(project.zipTree(omeroModel.file))
                    copySpec.setIncludeEmptyDirs(false)
                    copySpec.eachFile { FileCopyDetails copyDetails ->
                        copyDetails.path = copyDetails.name
                    }
                }
            })

            project.tasks.register(TASK_IMPORT_MAPPINGS, Sync, new Action<Sync>() {
                @Override
                void execute(Sync t) {
                    t.setGroup(GROUP)
                    t.into("$project.buildDir/mappings")
                    t.setIncludes([FileTypes.PATTERN_OME_XML])
                    t.with(copySpec)
                }
            })

            project.tasks.register(TASK_IMPORT_DATABASE_TYPES, Sync, new Action<Sync>() {
                @Override
                void execute(Sync t) {
                    t.setGroup(GROUP)
                    t.into("$project.buildDir/properties")
                    t.setIncludes([FileTypes.PATTERN_DB_TYPE])
                    t.with(copySpec)
                }
            })
        }
    }

    private static void configureForJavaPlugin(Project project, BlitzExtension blitz) {
        // Configure default outputDir
        project.plugins.withType(JavaPlugin) { JavaPlugin java ->
            // If we have java, resources are default here
            blitz.templates = project.fileTree(dir: "src/main/resources/templates",
                    include: FileTypes.PATTERN_TEMPLATE)

            JavaPluginConvention javaConvention =
                    project.convention.getPlugin(JavaPluginConvention)

            SourceSet main =
                    javaConvention.sourceSets.getByName(SourceSet.MAIN_SOURCE_SET_NAME)

            main.java.srcDirs "${blitz.outputDir}/java"
            main.resources.srcDirs "${blitz.outputDir}/resources"

            // Configure compileJava to depend on dsl tasks
            project.tasks.named("compileJava").configure { JavaCompile jc ->
                jc.dependsOn project.tasks.withType(GeneratorBaseTask)
            }
        }
    }

    private static void configureForApiPlugin(Project project) {
        project.plugins.withType(ApiPlugin) { ApiPlugin java ->
            // Set split tasks to depend on "generateCombinedFiles"
            project.tasks.withType(SplitTask).configureEach(new Action<SplitTask>() {
                @Override
                void execute(SplitTask t) {
                    t.combinedFiles = project.tasks.named(BlitzPluginBase.TASK_GENERATE_COMBINED_FILES)
                }
            })
        }
    }

}

